<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
<title>It's Rainbow in JavaScript!</title>
<!-- http://rocketnia.github.com/rainbow-js/test/index.html -->
<!--

Copyright (c) 2011 Ross Angle

This software is derived from Rainbow, software which is
copyright (c) 2011 Conan Dalton, distributed under the
Perl Foundation's Artistic License 2.0. In the sense described in
section (4)(c)(i) of that document, using its own terminology,
permission to use this "Modified Version" is granted under the
"Original License."

This software may also be derived from Arc, software which is
copyright (c) Paul Graham and Robert Morris, distributed under the
Perl Foundation's Artistic License 2.0. In the sense described in
section (4)(b) of that document, using its own terminology, this
"Modified Version" bears a name that is different from any name used
for Arc.

-->
<meta name="viewport" content=
   "initial-scale = 1.0, maximum-scale = 1.0, width = device-width" />
<style type="text/css">
#repl .scrollback {
    display: block;
    width: 95%;
    height: 200px;
    overflow: auto;
    resize: vertical;
    border: 2px solid black;
}
#repl .prompt { display: block; width: 95%; }
#repl .eval {}
</style>
<script type="text/javascript">"use strict";

(function () {

var root = window;


function shaveBytesFromAroundString( string ) {
    var chars = [];
    var leftoverByte = string.charCodeAt( 0 ) & 0xFF;
    for ( var i = 1, len = string.length; i < len; i++ ) {
        var code = string.charCodeAt( i );
        chars.push( root.String.fromCharCode(
            leftoverByte << 8 | (code >>> 8 & 0xFF) ) );
        leftoverByte = code & 0xFF;
    }
    return chars.join( "" );
}

// TODO: See what to do about concurrent reads. Right now we just
// always favor the latest read and never respond to the previous
// ones.
function makeInputAndOutput() {
    var buffer = "";
    var ignoringFirstByte = false;
    var closed = false;
    var callback = null, callbackMethod = null;
    
    function useCallback() {
        if ( callback === null )
            return;
        var then = callback, thenMethod = callbackMethod;
        callback = null, callbackMethod = null;
        thenMethod( then );
    }
    
    var output = {};
    output.writeString = function ( string ) {
        if ( closed ) return;
        buffer += string;
        useCallback();
    };
    output.writeByte = function ( theByte ) {
        if ( closed ) return;
        buffer = ignoringFirstByte ?
            shaveBytesFromAroundString( buffer ) +
                String.fromCharCode( theByte << 8 ) :
            shaveBytesFromAroundString(
                "\0" + buffer + String.fromCharCode( theByte << 8 ) );
        ignoringFirstByte = !ignoringFirstByte;
        useCallback();
    };
    output.close = function () {
        closed = true;
        useCallback();
    };
    output.flush = function () {};
    
    var input = {};
    var readByteAsync = input.readByteAsync = function (
        then, opt_sync ) {
        
        if ( buffer !== "" ) {
            var code = buffer.charCodeAt( 0 );
            var b = (ignoringFirstByte ? code : code >>> 8) & 0xFF;
            if ( ignoringFirstByte )
                buffer = buffer.substring( 1 );
            ignoringFirstByte = !ignoringFirstByte;
            then( null, b );
            return true;
        } else if ( closed ) {
            then( null, null );
            return true;
        } else if ( opt_sync ) {
            return false;
        } else {
            callback = then, callbackMethod = readByteAsync;
            return false;
        }
    };
    function peekOrReadCharCodeAsync(
        then, reading, method, opt_sync ) {
        
        if ( buffer !== "" ) {
            var c;
            if ( ignoringFirstByte ) {
                if ( buffer.length === 1 ) {
                    if ( closed ) {
                        // TODO: Figure out what to really do in this
                        // case. There's just one byte left in the
                        // stream, but we're reading or peeking at a
                        // character code....
                        if ( reading ) {
                            buffer = "";
                            ignoringFirstByte = false;
                        }
                        then( null, null );
                        return true;
                    } else if ( opt_sync ) {
                        return false;
                    } else {
                        callback = then, callbackMethod = method;
                        return false;
                    }
                }
                
                c = (buffer.charCodeAt( 0 ) << 8 & 0xFF00) |
                    (buffer.charCodeAt( 1 ) >>> 8 & 0xFF);
            } else {
                c = buffer.charCodeAt( 0 );
            }
            if ( reading )
                buffer = buffer.substring( 1 );
            then( null, c );
            return true;
        } else if ( closed ) {
            then( null, null );
            return true;
        } else if ( opt_sync ) {
            return false;
        } else {
            callback = then, callbackMethod = method;
            return false;
        }
    }
    var readCharCodeAsync = input.readCharCodeAsync = function (
        then, opt_sync ) {
        
        return peekOrReadCharCodeAsync(
            then, !!"reading", readCharCodeAsync, opt_sync );
    };
    var peekCharCodeAsync = input.peekCharCodeAsync = function (
        then, opt_sync ) {
        
        return peekOrReadCharCodeAsync(
            then, !"reading", peekCharCodeAsync, opt_sync );
    };
    input.close = function () {};
    
    return { i: input, o: output };
}

root.consoleIn = makeInputAndOutput();

root.rainbowStdin = makeInputAndOutput();
root.rainbowStdout = makeInputAndOutput();
root.rainbowStderr = makeInputAndOutput();

root.System_in = root.rainbowStdin.i;
root.System_out = root.rainbowStdout.o;
root.System_err = root.rainbowStderr.o;

})();

</script>
<script type="text/javascript" src="../rainbow.js"></script>
<script type="text/javascript">"use strict";

(function () {

var root = window;

// TODO: Turn this into a REPL rather than just an RPL.

root.onload = function () {
    
    var ENTER_KEY = 13;
    
    var repl = root.document.getElementById( "repl" );
    
    var scrollback = root.document.createElement( "pre" );
    scrollback.className = "scrollback";
    var scrollbackText = root.document.createTextNode( "" );
    scrollback.appendChild( scrollbackText );
    repl.appendChild( scrollback );
    
    var prompt = root.document.createElement( "textarea" );
    prompt.className = "prompt";
    prompt.addEventListener( "keydown", function ( event ) {
        if ( event.which === ENTER_KEY )
            event.preventDefault();
    }, !"capture" );
    prompt.addEventListener( "keyup", function ( event ) {
        if ( event.which === ENTER_KEY )
            doEval();
    }, !"capture" );
    repl.appendChild( prompt );
    
    var evalButton = root.document.createElement( "button" );
    evalButton.className = "eval";
    evalButton.appendChild( root.document.createTextNode( "Eval" ) );
    evalButton.addEventListener( "click", function ( event ) {
        doEval();
    }, !"capture" );
    repl.appendChild( evalButton );
    
    function doEval() {
        var command = prompt.value + "\n";
        prompt.value = "";
        root.consoleIn.o.writeString( command );
    }
    
    function readAllAvailable( stream, then ) {
        var chars = [];
        var error = null;
        while ( true ) {
            if ( !stream.readCharCodeAsync( function ( e, c ) {
                    if ( e )
                        error = e;
                    else
                        chars.push( root.String.fromCharCode( c ) );
                }, !!"sync" ) )
                return void then( null, chars.join( "" ) );
            
            if ( error )
                return void then( error );
        }
    }
    
    function processConsoleIn( e, c ) {
        if ( e ) throw e;
        if ( c === null ) return;
        readAllAvailable( root.consoleIn.i, function ( e, string ) {
            if ( e ) throw e;
            scrollbackText.data += string;
            scrollback.scrollTop = scrollback.scrollHeight;
            root.rainbowStdin.o.writeString( string );
            root.consoleIn.i.peekCharCodeAsync( processConsoleIn );
        } );
    }
    root.consoleIn.i.peekCharCodeAsync( processConsoleIn );
    
    function processStdout( e, c ) {
        if ( e ) throw e;
        if ( c === null ) return;
        readAllAvailable( root.rainbowStdout.i, function (
            e, string ) {
            
            if ( e ) throw e;
            scrollbackText.data += string;
            scrollback.scrollTop = scrollback.scrollHeight;
            root.rainbowStdout.i.peekCharCodeAsync( processStdout );
        } );
    }
    root.rainbowStdout.i.peekCharCodeAsync( processStdout );
    
    function processStderr( e, c ) {
        if ( e ) throw e;
        if ( c === null ) return;
        readAllAvailable( root.rainbowStderr.i, function (
            e, string ) {
            
            if ( e ) throw e;
            scrollbackText.data += string;
            scrollback.scrollTop = scrollback.scrollHeight;
            root.rainbowStderr.i.peekCharCodeAsync( processStderr );
        } );
    }
    root.rainbowStderr.i.peekCharCodeAsync( processStderr );
    
    root.Console.mainAsync( {}, function () {} );
};


})();

</script>
</head>
<body>
<p>This page loads rainbow.js (all 541 KB!) and exposes the REPL
  below. We don't load arc.arc automatically yet, but it does load
  without errors--which says little about whether the arc.arc
  utilities will actually behave as intended when they're called.</p>
<p>Actually, if you you paste from <a href=
  "https://github.com/conanite/rainbow/blob/92e07a98fd86f8e1985b32a7d2c265810eb76809/src/arc/arc.arc"
  >Java Rainbow's arc.arc source</a> yourself, you'll probably find
  that Rainbow.js encounters a stack overflow error. At this point
  it's necessary to enter it in more bite-size pieces. Right now you
  can accomplish this by pasting all of arc.arc into the input box,
  then entering the following code into a <i>JavaScript</i> console
  (not the Arc console!) to have it entered one line at a time:</p>
<pre>
var arcArc = document.getElementsByTagName( "textarea" )[ 0 ].
    value.split( "\n" );
function readRest() {
    if ( arcArc.length === 0 ) return;
    consoleIn.o.writeString( arcArc.shift() + "\n" );
    setTimeout( readRest, 0 );
}
readRest();
</pre>
<p>I've tested this in Chrome and Firefox so far.</p>
<div id="repl"></div>
<p>P.S.: Curious about what this stack overflow issue is? Well, I've
  set things up so that Rainbow.js takes its input asynchronously only
  when it's impossible to get the input right away. (It can get the
  input right away when it's been buffered, for instance.) This makes
  it possible to evaluate noninteractive Arc code from JavaScript
  synchronously, which is particularly important for a JavaScript
  toString() method. The problem is that this synchronous behavior is
  still based on calling CPS callbacks--namely, the same callbacks
  that are used for asynchronous results. All the callbacks within
  callbacks end up accumulating on the stack, and at some point it's
  too much.</p>
<p>Since this is now the main issue in the way of getting Rainbow.js
  to load arc.arc, it's next on my plate.</p>
<!-- TODO: Address that issue. In the most bottlenecked parts of the
  code, resort to switch statements or duplicated response-handling
  code. -->
</body>
</html>
