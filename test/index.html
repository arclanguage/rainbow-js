<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
<title>It's Rainbow in JavaScript!</title>
<!-- http://rocketnia.github.com/rainbow-js/test/index.html -->
<!--

Copyright (c) 2011 Ross Angle

This software is derived from Rainbow, software which is
copyright (c) 2011 Conan Dalton, distributed under the
Perl Foundation's Artistic License 2.0. In the sense described in
section (4)(c)(i) of that document, using its own terminology,
permission to use this "Modified Version" is granted under the
"Original License."

This software may also be derived from Arc, software which is
copyright (c) Paul Graham and Robert Morris, distributed under the
Perl Foundation's Artistic License 2.0. In the sense described in
section (4)(b) of that document, using its own terminology, this
"Modified Version" bears a name that is different from any name used
for Arc.

-->
<meta name="viewport" content=
   "initial-scale = 1.0, maximum-scale = 1.0, width = device-width" />
<style type="text/css">
html { font-family: sans-serif; }

body > pre { margin-left: 2em; }

#repl .scrollback {
    display: block;
    width: 95%;
    height: 200px;
    overflow: auto;
    resize: vertical;
    border: 2px solid black;
}
#repl .prompt { display: block; width: 95%; }
#repl .eval {}
</style>
<script type="text/javascript">"use strict";

(function () {

var root = window;


function shaveBytesFromAroundString( string ) {
    var chars = [];
    var leftoverByte = string.charCodeAt( 0 ) & 0xFF;
    for ( var i = 1, len = string.length; i < len; i++ ) {
        var code = string.charCodeAt( i );
        chars.push( root.String.fromCharCode(
            leftoverByte << 8 | (code >>> 8 & 0xFF) ) );
        leftoverByte = code & 0xFF;
    }
    return chars.join( "" );
}

// TODO: See what to do about concurrent reads. Right now we just
// always favor the latest read and never respond to the previous
// ones.
function makeInputAndOutput() {
    var buffer = "";
    var ignoringFirstByte = false;
    var closed = false;
    var callback = null, callbackMethod = null;
    
    function useCallback() {
        if ( callback === null )
            return;
        var then = callback, thenMethod = callbackMethod;
        callback = null, callbackMethod = null;
        thenMethod( then );
    }
    
    var output = {};
    output.writeString = function ( string ) {
        if ( closed ) return;
        buffer += string;
        useCallback();
    };
    output.writeByte = function ( theByte ) {
        if ( closed ) return;
        buffer = ignoringFirstByte ?
            shaveBytesFromAroundString( buffer ) +
                String.fromCharCode( theByte << 8 ) :
            shaveBytesFromAroundString(
                "\0" + buffer + String.fromCharCode( theByte << 8 ) );
        ignoringFirstByte = !ignoringFirstByte;
        useCallback();
    };
    output.close = function () {
        closed = true;
        useCallback();
    };
    output.flush = function () {};
    
    var input = {};
    var readByteAsync = input.readByteAsync = function (
        then, opt_sync ) {
        
        if ( buffer !== "" ) {
            var code = buffer.charCodeAt( 0 );
            var b = (ignoringFirstByte ? code : code >>> 8) & 0xFF;
            if ( ignoringFirstByte )
                buffer = buffer.substring( 1 );
            ignoringFirstByte = !ignoringFirstByte;
            then( null, b );
            return true;
        } else if ( closed ) {
            then( null, null );
            return true;
        } else if ( opt_sync ) {
            return false;
        } else {
            callback = then, callbackMethod = readByteAsync;
            return false;
        }
    };
    function peekOrReadCharCodeAsync(
        then, reading, method, opt_sync ) {
        
        if ( buffer !== "" ) {
            var c;
            if ( ignoringFirstByte ) {
                if ( buffer.length === 1 ) {
                    if ( closed ) {
                        // TODO: Figure out what to really do in this
                        // case. There's just one byte left in the
                        // stream, but we're reading or peeking at a
                        // character code....
                        if ( reading ) {
                            buffer = "";
                            ignoringFirstByte = false;
                        }
                        then( null, null );
                        return true;
                    } else if ( opt_sync ) {
                        return false;
                    } else {
                        callback = then, callbackMethod = method;
                        return false;
                    }
                }
                
                c = (buffer.charCodeAt( 0 ) << 8 & 0xFF00) |
                    (buffer.charCodeAt( 1 ) >>> 8 & 0xFF);
            } else {
                c = buffer.charCodeAt( 0 );
            }
            if ( reading )
                buffer = buffer.substring( 1 );
            then( null, c );
            return true;
        } else if ( closed ) {
            then( null, null );
            return true;
        } else if ( opt_sync ) {
            return false;
        } else {
            callback = then, callbackMethod = method;
            return false;
        }
    }
    var readCharCodeAsync = input.readCharCodeAsync = function (
        then, opt_sync ) {
        
        return peekOrReadCharCodeAsync(
            then, !!"reading", readCharCodeAsync, opt_sync );
    };
    var peekCharCodeAsync = input.peekCharCodeAsync = function (
        then, opt_sync ) {
        
        return peekOrReadCharCodeAsync(
            then, !"reading", peekCharCodeAsync, opt_sync );
    };
    input.close = function () {};
    
    return { i: input, o: output };
}

root.consoleIn = makeInputAndOutput();

root.rainbowStdin = makeInputAndOutput();
root.rainbowStdout = makeInputAndOutput();
root.rainbowStderr = makeInputAndOutput();

root.System_in = root.rainbowStdin.i;
root.System_out = root.rainbowStdout.o;
root.System_err = root.rainbowStderr.o;

})();

</script>
<script type="text/javascript" src="../rainbow.js"></script>
<script type="text/javascript">"use strict";

(function () {

var root = window;

function handle( el, eventName, handler ) {
    if ( el.addEventListener )
        el.addEventListener( eventName, handler, !"capture" );
    else  // IE
        el.attachEvent( "on" + eventName, handler );
}

function keyCode( event ) {
    return event.which ||
        event.keyCode;  // IE
}

function preventDefault( event ) {
    if ( event.preventDefault )
        event.preventDefault();
    else
        event.returnValue = false;  // IE
}

root.onload = function () {
    
    var ENTER_KEY = 13;
    
    var repl = root.document.getElementById( "repl" );
    
    var scrollback = root.document.createElement( "pre" );
    scrollback.className = "scrollback";
    var scrollbackText = root.document.createTextNode( "" );
    scrollback.appendChild( scrollbackText );
    repl.appendChild( scrollback );
    
    var prompt = root.document.createElement( "textarea" );
    prompt.className = "prompt";
    handle( prompt, "keydown", function ( event ) {
        if ( keyCode( event ) === ENTER_KEY )
            preventDefault( event );
    } );
    handle( prompt, "keyup", function ( event ) {
        if ( keyCode( event ) === ENTER_KEY )
            doEval();
    } );
    repl.appendChild( prompt );
    
    var evalButton = root.document.createElement( "button" );
    evalButton.className = "eval";
    evalButton.appendChild( root.document.createTextNode( "Eval" ) );
    handle( evalButton, "click", function ( event ) {
        doEval();
    } );
    repl.appendChild( evalButton );
    
    function doEval() {
        var command = prompt.value + "\n";
        prompt.value = "";
        root.consoleIn.o.writeString( command );
    }
    
    function readAllAvailable( stream, then ) {
        var chars = [];
        var error = null;
        while ( true ) {
            if ( !stream.readCharCodeAsync( function ( e, c ) {
                    if ( e )
                        error = e;
                    else
                        chars.push( root.String.fromCharCode( c ) );
                }, !!"sync" ) )
                return void then( null, chars.join( "" ) );
            
            if ( error )
                return void then( error );
        }
    }
    
    function processConsoleIn( e, c ) {
        if ( e ) throw e;
        if ( c === null ) return;
        readAllAvailable( root.consoleIn.i, function ( e, string ) {
            if ( e ) throw e;
            scrollbackText.data += string;
            scrollback.scrollTop = scrollback.scrollHeight;
            root.rainbowStdin.o.writeString( string );
            root.consoleIn.i.peekCharCodeAsync( processConsoleIn );
        } );
    }
    root.consoleIn.i.peekCharCodeAsync( processConsoleIn );
    
    function processStdout( e, c ) {
        if ( e ) throw e;
        if ( c === null ) return;
        readAllAvailable( root.rainbowStdout.i, function (
            e, string ) {
            
            if ( e ) throw e;
            scrollbackText.data += string;
            scrollback.scrollTop = scrollback.scrollHeight;
            root.rainbowStdout.i.peekCharCodeAsync( processStdout );
        } );
    }
    root.rainbowStdout.i.peekCharCodeAsync( processStdout );
    
    function processStderr( e, c ) {
        if ( e ) throw e;
        if ( c === null ) return;
        readAllAvailable( root.rainbowStderr.i, function (
            e, string ) {
            
            if ( e ) throw e;
            scrollbackText.data += string;
            scrollback.scrollTop = scrollback.scrollHeight;
            root.rainbowStderr.i.peekCharCodeAsync( processStderr );
        } );
    }
    root.rainbowStderr.i.peekCharCodeAsync( processStderr );
    
    root.Console.mainAsync( {}, function () {} );
};


})();

</script>
</head>
<body>
<p>This page loads rainbow.js (all 548 KB!) and exposes the REPL
  below. We don't load arc.arc automatically yet, but you can load it
  yourself by just copying <a href=
  "https://github.com/conanite/rainbow/blob/92e07a98fd86f8e1985b32a7d2c265810eb76809/src/arc/arc.arc"
  >Java Rainbow's arc.arc source</a> and pasting it all into the
  REPL. Although arc.arc will load, the utilities may not actually
  work when they're called. For instance, Rainbow.js doesn't implement
  file operations at all, so even though arc.arc defines
  <code>load</code>, it won't do us much good!</p>
<p>I've tested this in Chrome, Opera, Firefox, and IE. To
  compare them a bit, I pasted arc.arc surrounded by the following
  code...</p>
<pre>
(assign starttime (msec))

...

(- (msec) starttime)
</pre>
<p>...and got these results:</p>
<ul>
  <li>Chrome 13.0.782.112 m: <b>8614 ms</b></li>
  <li>Opera 11.50: <b>15059 ms</b></li>
  <li>Firefox 5.0: <b>17463 ms</b></li>
  <li>Internet Explorer 8.0.6001.18702: <b>106719 ms</b> (but this
    includes the time it took for me to dismiss four "Stop running
    this script?" dialogs)</li>
</ul>
<p>I was running all four browsers at the same time, so it was a
  pretty casual test. But hey, at least I wasn't <i>testing</i> them
  all at the same time. ^_^</p>
<div id="repl"></div>
</body>
</html>
