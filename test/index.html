<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
<title>It's Rainbow in JavaScript!</title>
<!-- http://rocketnia.github.com/rainbow-js/test/index.html -->
<!--

Copyright (c) 2011 Ross Angle

This software is derived from Rainbow, software which is
copyright (c) 2011 Conan Dalton, distributed under the
Perl Foundation's Artistic License 2.0. In the sense described in
section (4)(c)(i) of that document, using its own terminology,
permission to use this "Modified Version" is granted under the
"Original License."

This software may also be derived from Arc, software which is
copyright (c) Paul Graham and Robert Morris, distributed under the
Perl Foundation's Artistic License 2.0. In the sense described in
section (4)(b) of that document, using its own terminology, this
"Modified Version" bears a name that is different from any name used
for Arc.

-->
<meta name="viewport" content=
   "initial-scale = 1.0, maximum-scale = 1.0, width = device-width" />
<style type="text/css">
#repl .scrollback {
    display: block;
    width: 95%;
    height: 200px;
    overflow: auto;
    resize: vertical;
    border: 2px solid black;
}
#repl .prompt { display: block; width: 95%; }
#repl .eval {}
</style>
<script type="text/javascript">"use strict";

(function () {

var root = window;


function shaveBytesFromAroundString( string ) {
    var chars = [];
    var leftoverByte = string.charCodeAt( 0 ) & 0xFF;
    for ( var i = 1, len = string.length; i < len; i++ ) {
        var code = string.charCodeAt( i );
        chars.push( root.String.fromCharCode(
            leftoverByte << 8 | (code >>> 8 & 0xFF) ) );
        leftoverByte = code & 0xFF;
    }
    return chars.join( "" );
}

// TODO: See what to do about concurrent reads. Right now we just
// always favor the latest read and never respond to the previous
// ones.
function makeInputAndOutput() {
    var buffer = "";
    var ignoringFirstByte = false;
    var closed = false;
    var callback = null, callbackMethod = null;
    
    function useCallback() {
        if ( callback === null )
            return;
        var then = callback, thenMethod = callbackMethod;
        callback = null, callbackMethod = null;
        thenMethod( then );
    }
    
    var output = {};
    output.writeString = function ( string ) {
        if ( closed ) return;
        buffer += string;
        useCallback();
    };
    output.writeByte = function ( theByte ) {
        if ( closed ) return;
        buffer = ignoringFirstByte ?
            shaveBytesFromAroundString( buffer ) +
                String.fromCharCode( theByte << 8 ) :
            shaveBytesFromAroundString(
                "\0" + buffer + String.fromCharCode( theByte << 8 ) );
        ignoringFirstByte = !ignoringFirstByte;
        useCallback();
    };
    output.close = function () {
        closed = true;
        useCallback();
    };
    output.flush = function () {};
    
    var input = {};
    var readByteAsync = input.readByteAsync = function (
        then, opt_sync ) {
        
        if ( buffer !== "" ) {
            var code = buffer.charCodeAt( 0 );
            var b = (ignoringFirstByte ? code : code >>> 8) & 0xFF;
            if ( ignoringFirstByte )
                buffer = buffer.substring( 1 );
            ignoringFirstByte = !ignoringFirstByte;
            then( null, b );
            return true;
        } else if ( closed ) {
            then( null, null );
            return true;
        } else if ( opt_sync ) {
            return false;
        } else {
            callback = then, callbackMethod = readByteAsync;
            return false;
        }
    };
    function peekOrReadCharCodeAsync(
        then, reading, method, opt_sync ) {
        
        if ( buffer !== "" ) {
            var c;
            if ( ignoringFirstByte ) {
                if ( buffer.length === 1 ) {
                    if ( closed ) {
                        // TODO: Figure out what to really do in this
                        // case. There's just one byte left in the
                        // stream, but we're reading or peeking at a
                        // character code....
                        if ( reading ) {
                            buffer = "";
                            ignoringFirstByte = false;
                        }
                        then( null, null );
                        return true;
                    } else if ( opt_sync ) {
                        return false;
                    } else {
                        callback = then, callbackMethod = method;
                        return false;
                    }
                }
                
                c = (buffer.charCodeAt( 0 ) << 8 & 0xFF00) |
                    (buffer.charCodeAt( 1 ) >>> 8 & 0xFF);
            } else {
                c = buffer.charCodeAt( 0 );
            }
            if ( reading )
                buffer = buffer.substring( 1 );
            then( null, c );
            return true;
        } else if ( closed ) {
            then( null, null );
            return true;
        } else if ( opt_sync ) {
            return false;
        } else {
            callback = then, callbackMethod = method;
            return false;
        }
    }
    var readCharCodeAsync = input.readCharCodeAsync = function (
        then, opt_sync ) {
        
        return peekOrReadCharCodeAsync(
            then, !!"reading", readCharCodeAsync, opt_sync );
    };
    var peekCharCodeAsync = input.peekCharCodeAsync = function (
        then, opt_sync ) {
        
        return peekOrReadCharCodeAsync(
            then, !"reading", peekCharCodeAsync, opt_sync );
    };
    input.close = function () {};
    
    return { i: input, o: output };
}

root.consoleIn = makeInputAndOutput();

root.rainbowStdin = makeInputAndOutput();
root.rainbowStdout = makeInputAndOutput();
root.rainbowStderr = makeInputAndOutput();

root.System_in = root.rainbowStdin.i;
root.System_out = root.rainbowStdout.o;
root.System_err = root.rainbowStderr.o;

})();

</script>
<script type="text/javascript" src="../rainbow.js"></script>
<script type="text/javascript">"use strict";

(function () {

var root = window;

// TODO: Turn this into a REPL rather than just an RPL.

root.onload = function () {
    
    var ENTER_KEY = 13;
    
    var repl = root.document.getElementById( "repl" );
    
    var scrollback = root.document.createElement( "pre" );
    scrollback.className = "scrollback";
    var scrollbackText = root.document.createTextNode( "" );
    scrollback.appendChild( scrollbackText );
    repl.appendChild( scrollback );
    
    var prompt = root.document.createElement( "textarea" );
    prompt.className = "prompt";
    prompt.addEventListener( "keydown", function ( event ) {
        if ( event.which === ENTER_KEY )
            event.preventDefault();
    }, !"capture" );
    prompt.addEventListener( "keyup", function ( event ) {
        if ( event.which === ENTER_KEY )
            doEval();
    }, !"capture" );
    repl.appendChild( prompt );
    
    var evalButton = root.document.createElement( "button" );
    evalButton.className = "eval";
    evalButton.appendChild( root.document.createTextNode( "Eval" ) );
    evalButton.addEventListener( "click", function ( event ) {
        doEval();
    }, !"capture" );
    repl.appendChild( evalButton );
    
    function doEval() {
        var command = prompt.value + "\n";
        prompt.value = "";
        root.consoleIn.o.writeString( command );
    }
    
    function readAllAvailable( stream, then ) {
        var chars = [];
        var error = null;
        while ( true ) {
            if ( !stream.readCharCodeAsync( function ( e, c ) {
                    if ( e )
                        error = e;
                    else
                        chars.push( root.String.fromCharCode( c ) );
                }, !!"sync" ) )
                return void then( null, chars.join( "" ) );
            
            if ( error )
                return void then( error );
        }
    }
    
    function processConsoleIn( e, c ) {
        if ( e ) throw e;
        if ( c === null ) return;
        readAllAvailable( root.consoleIn.i, function ( e, string ) {
            if ( e ) throw e;
            scrollbackText.data += string;
            scrollback.scrollTop = scrollback.scrollHeight;
            root.rainbowStdin.o.writeString( string );
            root.consoleIn.i.peekCharCodeAsync( processConsoleIn );
        } );
    }
    root.consoleIn.i.peekCharCodeAsync( processConsoleIn );
    
    function processStdout( e, c ) {
        if ( e ) throw e;
        if ( c === null ) return;
        readAllAvailable( root.rainbowStdout.i, function (
            e, string ) {
            
            if ( e ) throw e;
            scrollbackText.data += string;
            scrollback.scrollTop = scrollback.scrollHeight;
            root.rainbowStdout.i.peekCharCodeAsync( processStdout );
        } );
    }
    root.rainbowStdout.i.peekCharCodeAsync( processStdout );
    
    function processStderr( e, c ) {
        if ( e ) throw e;
        if ( c === null ) return;
        readAllAvailable( root.rainbowStderr.i, function (
            e, string ) {
            
            if ( e ) throw e;
            scrollbackText.data += string;
            scrollback.scrollTop = scrollback.scrollHeight;
            root.rainbowStderr.i.peekCharCodeAsync( processStderr );
        } );
    }
    root.rainbowStderr.i.peekCharCodeAsync( processStderr );
    
    root.Console.mainAsync( {}, function () {} );
};


})();

</script>
</head>
<body>
<p>This page loads rainbow.js (all 541 KB!) and exposes the REPL
  below. We don't load arc.arc automatically yet, but you can load it
  yourself by just copying <a href=
  "https://github.com/conanite/rainbow/blob/92e07a98fd86f8e1985b32a7d2c265810eb76809/src/arc/arc.arc"
  >Java Rainbow's arc.arc source</a> and pasting it all into the
  REPL. It loads without errors, but that says little about whether
  the utilities will actually behave as intended when they're
  called.</p>
<p>I've tested this in Chrome and Firefox so far.</p>
<div id="repl"></div>
</body>
</html>
